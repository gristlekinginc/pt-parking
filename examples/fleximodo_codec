// Encode downlink function.
//
// Input is an object with the following fields:
// - data = Object representing the payload that must be encoded.
// - variables = Object containing the configured device variables.
//
// Output must be an object with the following fields:
// - bytes = Byte array containing the downlink payload.
function encodeDownlink(input) {
  return {
    bytes: [225, 230, 255, 0]
  };
}


function decodeUplink(input) {
  var bytes = input.bytes;
  var decoded = {};
  var warnings = [];
  var errors = [];

  // Interpret the first two bytes as a 16-bit number
  var statusBits = (bytes[0] << 8) + bytes[1];

  // Qualification phase
  if (statusBits & 0x4000) {
    errors.push("Sensor not calibrated");
  } else if (statusBits & 0x0010 || statusBits & 0x0800 || statusBits & 0x2000) {
    warnings.push("Message ignored");
  } else if ((statusBits & 0x0001) === (statusBits & 0x0002)) {  // Neither or both 0x0001 and 0x0002 are set
    errors.push("Internal sensor error");
  } else if (statusBits & 0x0020 || statusBits & 0x0400) {
    errors.push("Internal sensor error");
  }

  // Decision phase
  if (!errors.length) {
    if (statusBits & 0x1000) {
      decoded.message = "KEEP-ALIVE";
    } else if (!(statusBits & 0x0008)) {
      warnings.push("Message ignored");
    } else {
      decoded.statusChanged = true; // assuming previous status is available somewhere
    }
    
    if (!decoded.statusChanged) {
      if (statusBits & 0x0100) {
        warnings.push("Duplicity message");
      } else {
        decoded.message = "New status reported";
      }
    }
  }

  // Check parking status
  if (!errors.length) {
    if (statusBits & 0x0001) {
      decoded.parkingStatus = "FREE";
    } else if (statusBits & 0x0002) {
      decoded.parkingStatus = "BUSY";
    }
  }

  // Decode battery capacity
  if (decoded.message === "KEEP-ALIVE" && bytes.length >= 8) {
    var batteryCapacity = (bytes[6] | (bytes[7] << 8)); // Little Endianness
    decoded.remainingBatteryCapacity = 13000 - batteryCapacity;
  }

  // iPermit cards
  if (bytes.length > 10) {
    var cardBytes = bytes.slice(10);
    var cardId = cardBytes.slice(0, 6).map(byte => ('0' + byte.toString(16)).slice(-2)).join(' ');
    decoded.iPermitCardId = cardId;
  }

  return {
    data: decoded,
    warnings: warnings,
    errors: errors
  };
}

